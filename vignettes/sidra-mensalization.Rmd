---
title: "From Rolling Quarters to Monthly Estimates: SIDRA Mensalization Guide"
author: "Rogerio Barbosa"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{From Rolling Quarters to Monthly Estimates: SIDRA Mensalization Guide}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = FALSE,
  purl = FALSE
)
```

This vignette provides a comprehensive tutorial on converting Brazil's PNADC rolling
quarter data into exact monthly estimates using the SIDRA mensalization module.

## Overview

The PNADCperiods package includes a complete module for **mensalizing** (converting
to monthly) the labor market indicators published by IBGE through the SIDRA API.
This module implements the methodology developed by Marcos Hecksher, enabling
researchers to obtain true monthly estimates rather than the smoothed rolling
quarterly averages published by IBGE.

**What you'll learn:**

- Why rolling quarters obscure monthly dynamics
- How to obtain monthly estimates in just 3 lines of code
- How to work with 70+ economic indicators
- The underlying methodology (for those who want to understand)
- How to compute custom starting points from microdata

---

## Section 1: Introduction — The Monthly Data Problem

### Why PNADC Uses Rolling Quarters

Brazil's Continuous National Household Sample Survey (PNADC) collects data
monthly but publishes indicators as **rolling (moving) quarters**. Each published
"quarter" actually represents a 3-month moving average:

- "2019-Q1" = average of Jan, Feb, Mar 2019
- "2019-Q2" = average of Feb, Mar, Apr 2019
- "2019-Q3" = average of Mar, Apr, May 2019

This design has statistical advantages (smaller standard errors), but creates
serious problems for time series analysis.

```{r fig1, echo=FALSE, out.width="100%", fig.cap="Rolling quarters overlap: each 'quarter' shares 2 months with its neighbors"}
knitr::include_graphics("figures/sidra-mensalization/fig1_rolling_schematic.png")
```

### Problems for Researchers

**1. Temporal smoothing hides dynamics**

When unemployment jumps in March, the rolling quarter "smooths" this across
Jan-Feb-Mar, Feb-Mar-Apr, and Mar-Apr-May. The true March spike is diluted
and spread across multiple periods.

**2. Missed turning points**

Economic turning points (recession starts, recovery begins) are delayed and
attenuated in rolling quarter data. A sharp monthly change becomes a gradual
quarterly shift.

**3. Seasonal adjustment difficulties**

Standard seasonal adjustment methods assume non-overlapping periods. Applying
them to rolling quarters produces biased results because adjacent observations
share 2/3 of their data.

**4. International comparability**

Most countries (US Bureau of Labor Statistics, Eurostat) publish monthly
employment statistics. Rolling quarters make direct comparison difficult.

### What Mensalization Provides

The mensalization methodology developed by Marcos Hecksher recovers the **exact
monthly estimates** from rolling quarter data. This gives you:

- True monthly values for each reference month
- Proper inputs for seasonal adjustment
- Comparable data with international statistics
- Clear identification of turning points

**Common misconception:** "Can't I just divide by 3?"

No. Each rolling quarter is a weighted average, and the weights are calibrated
to the full quarter's population. Simply dividing by 3 would give incorrect
estimates. The mensalization algorithm properly inverts the averaging process.

---

## Section 2: Quick Start — Monthly Data in 3 Lines

### The Minimal Workflow

```{r quickstart, eval=FALSE}
library(PNADCperiods)

# Step 1: Fetch rolling quarter data from SIDRA API
rolling_quarters <- fetch_sidra_rolling_quarters()

# Step 2: Convert to monthly estimates
monthly <- mensalize_sidra_series(rolling_quarters)

# Step 3: Use your monthly data!
head(monthly[, .(anomesexato, m_popocup, m_taxadesocup)])
```

**Output:**

```
   anomesexato m_popocup m_taxadesocup
1:      201203  88529.88          8.32
2:      201204  89333.41          8.48
3:      201205  89314.28          8.14
4:      201206  89461.69          7.74
5:      201207  89418.66          7.58
6:      201208  89677.32          7.52
```

That's it! You now have monthly estimates starting from March 2012.

### What Just Happened?

1. **`fetch_sidra_rolling_quarters()`** downloaded 70+ economic indicators
   from IBGE's SIDRA API (Tables 4093, 6390, 6392, 6399, 6906)

2. **`mensalize_sidra_series()`** applied the Hecksher formula using
   pre-computed starting points (bundled with the package)

3. The result is a `data.table` with monthly estimates for all series

### Understanding the Output

The output contains:

- `anomesexato`: Month identifier (YYYYMM format, e.g., 201903 = March 2019)
- `m_*` columns: Mensalized (monthly) estimates for each series
- Price indices: `ipca100dez1993`, `inpc100dez1993` (for deflation)

**Key series include:**

| Column | Description | Unit |
|--------|-------------|------|
| `m_populacao` | Total population | Thousands |
| `m_pop14mais` | Population 14+ years | Thousands |
| `m_popocup` | Employed population | Thousands |
| `m_popdesocup` | Unemployed population | Thousands |
| `m_taxadesocup` | Unemployment rate | Percent |
| `m_taxapartic` | Labor force participation rate | Percent |
| `m_massahabnominaltodos` | Total nominal wage bill | Millions R$ |

### Discovering Available Series

Use `get_sidra_series_metadata()` to explore all 86 available series:

```{r metadata, eval=FALSE}
meta <- get_sidra_series_metadata()

# View series by category
meta[category == "employment", .(series_name, description)]
```

**Output:**

```
          series_name                                    description
1:          empregado                           Total employed workers
2:         empregpriv           Private sector employees (all types)
3:    empregprivcomcart    Private sector employees with formal contract
4:    empregprivsemcart Private sector employees without formal contract
5:           domestico                             Domestic workers (all)
...
```

### Top 10 Most Commonly Used Series

| Series | Description |
|--------|-------------|
| `m_taxadesocup` | Unemployment rate (%) |
| `m_taxapartic` | Labor force participation rate (%) |
| `m_popocup` | Employed population (thousands) |
| `m_popdesocup` | Unemployed population (thousands) |
| `m_nivelocup` | Employment-population ratio (%) |
| `m_massahabnominaltodos` | Total nominal wage bill |
| `m_rendhabnominaltodos` | Average nominal income |
| `m_subocuphoras` | Underemployed by hours (thousands) |
| `m_taxacompsubutlz` | Composite underutilization rate (%) |
| `m_perccontribprev` | Social security contribution rate (%) |

---

## Section 3: Understanding the Data Flow

### Three-Step Mental Model

The mensalization process follows a simple pipeline:

```
SIDRA API → Rolling Quarters → Mensalization → Monthly Estimates
```

```{r fig2, echo=FALSE, out.width="100%", fig.cap="Data flow from SIDRA to monthly estimates"}
knitr::include_graphics("figures/sidra-mensalization/fig2_data_flow.png")
```

### Step 1: Fetching Rolling Quarter Data

The `fetch_sidra_rolling_quarters()` function downloads data from five SIDRA tables:

| Table | Content |
|-------|---------|
| 4093 | Population and labor force |
| 6390 | Income (nominal and real) |
| 6392 | Real income by occupation |
| 6399 | Employment by sector |
| 6906 | Underutilization indicators |

```{r fetch-inspect, eval=FALSE}
rq <- fetch_sidra_rolling_quarters(verbose = TRUE)

# Inspect structure
dim(rq)
names(rq)[1:20]
```

**Key columns in rolling quarter data:**

- `anomesfinaltrimmovel`: End month of rolling quarter (YYYYMM)
- `populacao`, `pop14mais`, `popocup`, etc.: Level estimates (thousands)
- `taxadesocup`, `taxapartic`, etc.: Rate estimates (percent)

### Step 2: The Mensalization Transform

The `mensalize_sidra_series()` function converts rolling quarters to monthly:

```{r mensalize-inspect, eval=FALSE}
monthly <- mensalize_sidra_series(rq, verbose = TRUE)

# Compare dimensions
cat("Rolling quarters:", nrow(rq), "rows\n")
cat("Monthly data:", nrow(monthly), "rows\n")
```

The number of rows is approximately the same (one per month), but the meaning
changes from "rolling quarter ending in month X" to "exact estimate for month X".

### Step 3: Using Monthly Estimates

Monthly estimates are ready for analysis:

```{r use-monthly, eval=FALSE}
# Time series plot
library(ggplot2)

monthly[, date := as.Date(paste0(substr(anomesexato, 1, 4), "-",
                                  substr(anomesexato, 5, 6), "-01"))]

ggplot(monthly, aes(x = date, y = m_taxadesocup)) +
  geom_line() +
  labs(title = "Monthly Unemployment Rate",
       y = "Unemployment Rate (%)")
```

### Population Data for Weighting

For some analyses, you may need monthly population estimates separately:

```{r pop-data, eval=FALSE}
pop <- fetch_monthly_population()
head(pop)
```

This returns a data.table with `ref_month_yyyymm` and `m_populacao` columns,
useful for computing weighted aggregates or population-adjusted rates.

---

## Section 4: Working with Multiple Series

### Fetching by Category

Instead of fetching all 86 series, you can filter by category:

```{r by-category, eval=FALSE}
# Only employment series (18 series)
employment <- fetch_sidra_rolling_quarters(category = "employment")

# Only population series (6 series)
population <- fetch_sidra_rolling_quarters(category = "population")

# Available categories:
# "population", "employment", "sector", "income_nominal",
# "income_real", "underutilization", "price_index", "rate"
```

### Fetching Specific Series

For maximum efficiency, request only the series you need:

```{r specific-series, eval=FALSE}
# Only unemployment-related series
unemp <- fetch_sidra_rolling_quarters(
  series = c("popdesocup", "taxadesocup", "popnaforca")
)
```

### Date Range Filtering

Limit data to a specific period:

```{r date-filter, eval=FALSE}
# Only 2019-2023
recent <- fetch_sidra_rolling_quarters(
  start_period = 201901L,
  end_period = 202312L
)
```

### Excluding Derived Series

Some series are rates computed from other series. To fetch only "base" series:

```{r exclude-derived, eval=FALSE}
# Exclude computed rates (only population and income levels)
base_only <- fetch_sidra_rolling_quarters(exclude_derived = TRUE)
```

### Working with Mensalized Output

After mensalization, select columns as needed:

```{r select-columns, eval=FALSE}
monthly <- mensalize_sidra_series(rq)

# Select specific series
labor_market <- monthly[, .(
  anomesexato,
  employed = m_popocup,
  unemployed = m_popdesocup,
  unemp_rate = m_taxadesocup,
  participation = m_taxapartic
)]
```

---

## Section 5: The Mensalization Methodology (Deep Dive)

*[This section can be skipped by users who just need results]*

### The Core Concept

Rolling quarters are 3-month moving averages. If we denote the true monthly
value for month $t$ as $y_t$, then the rolling quarter value $x_t$ is:

$$x_t = \frac{y_{t-2} + y_{t-1} + y_t}{3}$$

The mensalization algorithm inverts this relationship to recover $y_t$ from
the sequence of $x_t$ values.

### The Hecksher Formula

The algorithm uses three key steps:

**Step 1: Compute first differences**

$$d3_t = x_t - x_{t-1}$$

This "first difference" captures how much the rolling quarter changed.

**Step 2: Identify month position (mesnotrim)**

Each month has a position within its quarter:
- Position 1: Jan, Apr, Jul, Oct
- Position 2: Feb, May, Aug, Nov
- Position 3: Mar, Jun, Sep, Dec

**Step 3: Cumulative sum by position**

For each position separately, compute the cumulative sum of first differences,
starting from a calibrated "starting point" $y_0$:

$$y_t = y_0 + \sum_{s \in \text{same position}, s \leq t} d3_s$$

```{r fig3, echo=FALSE, out.width="100%", fig.cap="Mensalization process: rolling quarters (blue) vs monthly estimates (red)"}
knitr::include_graphics("figures/sidra-mensalization/fig3_mensalization_process.png")
```

### The Role of Starting Points (y0)

The starting point $y_0$ is crucial. It determines the **level** of all
subsequent monthly estimates. The package includes pre-computed starting points
for 53 series, calibrated during the stable 2013-2019 period.

Starting points are computed by:
1. Processing PNADC microdata to get "true" monthly aggregates (z_)
2. Comparing these to rolling quarters
3. Finding the value that makes $y_0 + \text{cumsum}(d3)$ match the microdata

### Assumptions and Limitations

**Assumptions:**
- Monthly values within each position evolve smoothly
- The calibration period (2013-2019) reflects "normal" conditions
- SIDRA rolling quarters are accurate

**Limitations:**
- Cannot recover intra-month variation
- Assumes constant seasonal pattern across years
- Starting points are calibrated to national totals (not regional breakdowns)

---

## Section 6: Practical Considerations

### API Caching

The package caches SIDRA API responses to avoid repeated downloads:

```{r cache, eval=FALSE}
# First call: fetches from API
rq1 <- fetch_sidra_rolling_quarters()  # Takes ~10 seconds

# Second call: uses cache
rq2 <- fetch_sidra_rolling_quarters()  # Instant

# Force fresh fetch
rq3 <- fetch_sidra_rolling_quarters(use_cache = FALSE)

# Clear all cached data
clear_sidra_cache()
```

Cache expires after 24 hours by default. Set custom expiration:

```{r cache-age, eval=FALSE}
rq <- fetch_sidra_rolling_quarters(cache_max_age_hours = 48)
```

### Error Handling

**Common errors and solutions:**

| Error | Cause | Solution |
|-------|-------|----------|
| "Series not found" | Misspelled series name | Check `get_sidra_series_metadata()` |
| "API timeout" | SIDRA server slow | Retry; use `use_cache = TRUE` |
| "No starting points" | Custom series | See Section 7 |

```{r error-handling, eval=FALSE}
# Check if series exists
meta <- get_sidra_series_metadata()
"taxadesocup" %in% meta$series_name  # TRUE

# Validate before mensalizing
tryCatch({
  monthly <- mensalize_sidra_series(rq, series = "invalid_name")
}, error = function(e) {
  message("Error: ", e$message)
})
```

### Data Quality Notes

**COVID-19 disruptions (2020):**
IBGE suspended in-person interviews during the pandemic, affecting data
collection. Some indicators show unusual patterns in 2020-Q2.

**Variable availability:**
Not all series are available from March 2012. Some start later:
- CNPJ-based series (empregadorcomcnpj, etc.): From October 2015
- Some income measures: Variable availability

Check availability:
```{r availability, eval=FALSE}
meta <- get_sidra_series_metadata()
meta[, .(series_name, available_from)]
```

---

## Section 7: Advanced — Custom Starting Points

*[For users with calibrated PNADC microdata]*

### When You Need Custom Starting Points

Use the bundled starting points (default) unless:

1. **Your series isn't bundled** — Custom variable definitions
2. **Different calibration period** — Non-standard reference period
3. **Regional breakdown** — State or metro-area mensalization
4. **Methodological research** — Testing alternative calibrations

### Decision Tree

```
Do you need standard national-level series?
├── YES → Use bundled starting points (default)
└── NO → Do you have calibrated PNADC microdata?
    ├── YES → Compute custom starting points
    └── NO → Calibrate microdata first (see main vignette)
```

### Option A: All-in-One Function

```{r custom-y0-allinone, eval=FALSE}
# Load your stacked PNADC microdata (with pnadc_apply_periods weights)
stacked <- readRDS("my_calibrated_pnadc.rds")

# Compute starting points
custom_y0 <- compute_starting_points_from_microdata(
  data = stacked,
  calibration_start = 201301L,
  calibration_end = 201912L,
  verbose = TRUE
)

# Use custom starting points
monthly <- mensalize_sidra_series(rq, starting_points = custom_y0)
```

### Option B: Step-by-Step (for debugging)

```{r custom-y0-stepbystep, eval=FALSE}
# Step 1: Build crosswalk and calibrate (existing functions)
crosswalk <- pnadc_identify_periods(stacked)
calibrated <- pnadc_apply_periods(
  stacked, crosswalk,
  weight_var = "V1028",
  calibration_unit = "month"
)

# Step 2: Compute z_ aggregates (monthly totals from microdata)
z_agg <- compute_z_aggregates(calibrated)

# Step 3: Fetch rolling quarters for comparison
rq <- fetch_sidra_rolling_quarters()

# Step 4: Compute starting points
y0 <- compute_series_starting_points(
  monthly_estimates = z_agg,
  rolling_quarters = rq,
  calibration_start = 201301L,
  calibration_end = 201912L
)

# Step 5: Use custom starting points
result <- mensalize_sidra_series(rq, starting_points = y0)
```

### Special Cases

**CNPJ series (empregadorcomcnpj, contapropriacomcnpj, etc.):**

The V4019 variable (CNPJ registration) is only available from October 2015.
Use a later calibration period:

```{r cnpj-calibration, eval=FALSE}
y0_cnpj <- compute_series_starting_points(
  z_agg, rq,
  calibration_start = 201601L,  # Not 201301!
  calibration_end = 201912L,
  use_series_specific_periods = TRUE  # Auto-adjust for CNPJ series
)
```

**subocuphoras (underemployment by hours):**

This series uses different PNADC variables before/after September 2015
(VD4004 vs VD4004A). The package handles this automatically with split
calibration.

### Validating Custom Starting Points

Compare your custom y0 against the bundled values:

```{r validate-y0, eval=FALSE}
bundled <- pnadc_series_starting_points

# Merge and compare
comp <- merge(custom_y0, bundled,
              by = c("series_name", "mesnotrim"),
              suffixes = c("_custom", "_bundled"))

comp[, rel_diff := abs(y0_custom - y0_bundled) / abs(y0_bundled) * 100]

# Check differences
summary(comp$rel_diff)
comp[rel_diff > 1]  # Flag series with >1% difference
```

---

## Section 8: Case Study — COVID-19 Unemployment

### Research Question

How quickly did unemployment rise when COVID-19 hit Brazil, and how quickly
did it recover? Rolling quarter data obscures these dynamics.

### Analysis

```{r covid-analysis, eval=FALSE}
# Fetch and mensalize unemployment data
rq <- fetch_sidra_rolling_quarters(series = c("taxadesocup", "popdesocup"))
monthly <- mensalize_sidra_series(rq)

# Filter to COVID period
covid_period <- monthly[anomesexato >= 201901 & anomesexato <= 202212]

# Create date column
covid_period[, date := as.Date(paste0(
  substr(anomesexato, 1, 4), "-",
  substr(anomesexato, 5, 6), "-01"
))]

# Find peak
peak_month <- covid_period[which.max(m_taxadesocup)]
cat("Peak unemployment:", peak_month$m_taxadesocup, "% in",
    format(peak_month$date, "%B %Y"), "\n")
```

```{r fig4, echo=FALSE, out.width="100%", fig.cap="Monthly vs rolling quarter unemployment rate (2019-2023)"}
knitr::include_graphics("figures/sidra-mensalization/fig4_monthly_vs_quarterly.png")
```

### What Monthly Data Reveals

```{r fig5, echo=FALSE, out.width="100%", fig.cap="COVID-19 impact on Brazilian unemployment"}
knitr::include_graphics("figures/sidra-mensalization/fig5_covid_case_study.png")
```

**Key findings from monthly estimates:**

1. **Exact peak timing**: Unemployment peaked in the exact month when
   rolling quarters show only a gradual rise

2. **Speed of job losses**: The monthly data shows a sharp spike that
   rolling quarters smooth over 3+ months

3. **Recovery pattern**: The monthly series reveals that recovery was
   not smooth—it had pauses and reversals hidden in quarterly averages

4. **Information hidden in rolling averages**: A 2-percentage-point rise
   spread over 3 rolling quarters is actually a 4+ point monthly spike
   followed by partial recovery

---

## Section 9: Reference — Series Catalog

### Series Naming Conventions

| Prefix | Meaning | Example |
|--------|---------|---------|
| `m_` | Mensalized monthly estimate | `m_popocup` |
| `pop*` | Population count | `populacao`, `pop14mais` |
| `*comcart` | With formal contract | `empregprivcomcart` |
| `*semcart` | Without formal contract | `empregprivsemcart` |
| `*comcnpj` | With CNPJ registration | `empregadorcomcnpj` |
| `*semcnpj` | Without CNPJ registration | `empregadorsemcnpj` |
| `taxa*` | Rate (percent) | `taxadesocup` |
| `nivel*` | Level/ratio (percent) | `nivelocup` |
| `perc*` | Percentage | `perccontribprev` |
| `rend*` | Income (rendimento) | `rendhabnominaltodos` |
| `massa*` | Wage bill (massa salarial) | `massahabnominaltodos` |
| `*hab*` | Usually received (habitual) | `rendhabnominaltodos` |
| `*efet*` | Actually received (efetivo) | `rendefetnominaltodos` |
| `*ipcabr*` | Deflated by IPCA | `massahabtodosipcabr` |

### Complete Series List by Category

```{r series-catalog, eval=FALSE}
meta <- get_sidra_series_metadata()

# View all series grouped by category
for (cat in unique(meta$category)) {
  cat("\n###", toupper(cat), "###\n")
  print(meta[category == cat, .(series_name, description)])
}
```

**Population (6 series):**
`populacao`, `pop14mais`, `popnaforca`, `popocup`, `popdesocup`, `popforadaforca`

**Employment (18 series):**
`empregado`, `empregpriv`, `empregprivcomcart`, `empregprivsemcart`,
`domestico`, `domesticocomcart`, `domesticosemcart`, `empregpubl`,
`empregpublcomcart`, `empregpublsemcart`, `estatutmilitar`, `empregador`,
`empregadorcomcnpj`, `empregadorsemcnpj`, `contapropria`, `contapropriacomcnpj`,
`contapropriasemcnpj`, `trabfamauxiliar`

**Sector (10 series):**
`agropecuaria`, `industria`, `construcao`, `comercio`, `transporte`,
`alojaliment`, `infcomfinimobadm`, `adminpublica`, `outroservico`,
`servicodomestico`

**Income - Nominal (4 series):**
`rendhabnominaltodos`, `rendefetnominaltodos`, `massahabnominaltodos`,
`massaefetnominaltodos`

**Underutilization (11 series):**
`contribuinteprev`, `subocuphoras`, `forcapotencial`, `forcaampliada`,
`desalentado`, `comrendtodos` (plus derived rates)

**Rates (computed, 12 series):**
`taxapartic`, `nivelocup`, `niveldesocup`, `taxadesocup`, `perccontribprev`,
`taxasubocuphoras`, `taxacombdesosub`, `taxacombdesopot`, `taxacompsubutlz`,
`percdesalento`

### Programmatic Access

```{r programmatic-access, eval=FALSE}
meta <- get_sidra_series_metadata()

# Filter by multiple criteria
employment_rates <- meta[
  category %in% c("employment", "rate") &
  grepl("taxa|nivel", series_name)
]

# Get series available from a specific date
post_2015 <- meta[available_from >= 201510]
```

---

## Section 10: Troubleshooting and FAQ

### Common Errors

**"Error: Series 'xyz' not found"**

Check spelling and availability:
```{r error-series, eval=FALSE}
meta <- get_sidra_series_metadata()
meta[grepl("xyz", series_name, ignore.case = TRUE)]
```

**"Error: No starting points available for series 'xyz'"**

The bundled starting points cover 53 series. For custom series, compute your
own starting points (see Section 7).

**"SIDRA API timeout"**

The SIDRA server may be slow. Solutions:
1. Retry after a few minutes
2. Use `use_cache = TRUE` to avoid re-downloading
3. Fetch smaller subsets: `fetch_sidra_rolling_quarters(category = "employment")`

**"Unexpected NA values in output"**

Some series have limited date availability:
```{r na-values, eval=FALSE}
# Check when series becomes available
monthly[, .(first_valid = min(anomesexato[!is.na(m_empregadorcomcnpj)])),
        by = .(year = anomesexato %/% 100)]
```

### Frequently Asked Questions

**Q: How accurate are the monthly estimates?**

A: The monthly estimates exactly match the methodology used by IBGE internally
and validated against Marcos Hecksher's reference implementation. For the 57
series with bundled starting points, 98% have maximum discrepancy < 1% compared
to the reference.

**Q: Can I use this for regional (state-level) estimates?**

A: The current module only supports national-level estimates. State-level
mensalization would require state-level starting points computed from microdata.

**Q: How do I cite this methodology?**

A: Cite Marcos Hecksher's original work and this package:

> Hecksher, M. (2021). Mensalization of PNADC Series. *IPEA Technical Note*.
>
> Barbosa, R. (2024). PNADCperiods: Sub-quarterly PNADC Time Series. R package
> version 0.1.0. https://github.com/antrologos/PNADCperiods

**Q: Why do some rates show larger discrepancies than levels?**

A: Rates are computed as ratios (e.g., `m_popdesocup / m_popnaforca * 100`).
Small differences in the numerator and denominator can produce larger percentage
differences in the ratio, especially for rates near 0% or 100%.

**Q: Can I mensalize my own custom indicators?**

A: Yes, if you have:
1. PNADC microdata with the indicator
2. Calibrated monthly weights (from `pnadc_apply_periods()`)

Then use `compute_starting_points_from_microdata()` to generate custom y0 values.

### Getting Help

- **Package issues**: https://github.com/antrologos/PNADCperiods/issues
- **Methodology questions**: See Marcos Hecksher's IPEA publications
- **SIDRA API**: https://sidra.ibge.gov.br/

---

## Summary: Function Reference

| Function | Purpose | When to Use |
|----------|---------|-------------|
| `fetch_sidra_rolling_quarters()` | Download SIDRA data | First step |
| `fetch_monthly_population()` | Get population series | For weighting |
| `mensalize_sidra_series()` | Convert to monthly | Main transformation |
| `get_sidra_series_metadata()` | Explore series | Finding variable names |
| `clear_sidra_cache()` | Reset cache | After data updates |
| `compute_z_aggregates()` | Microdata → z_ | Custom starting points |
| `compute_series_starting_points()` | z_ → y0 | Custom starting points |
| `compute_starting_points_from_microdata()` | All-in-one | Custom starting points |

**Bundled data:**
- `pnadc_series_starting_points`: Pre-computed y0 for 53 series × 3 positions
